const DEG2RAD = Math.PI / 180;

class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }

  set(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }

  clone() {
    return new Vector3(this.x, this.y, this.z);
  }

  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }

  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
}

class Euler {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }

  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
}

class Color {
  constructor(value = '#ffffff') {
    this.set(value);
  }

  set(value) {
    if (value instanceof Color) {
      this.r = value.r;
      this.g = value.g;
      this.b = value.b;
      return this;
    }
    if (typeof value === 'string' && value.startsWith('#')) {
      const normalized = value.replace('#', '');
      const intValue = parseInt(normalized, 16);
      if (!Number.isNaN(intValue)) {
        if (normalized.length === 3) {
          this.r = ((intValue >> 8) & 0xf) / 15;
          this.g = ((intValue >> 4) & 0xf) / 15;
          this.b = (intValue & 0xf) / 15;
        } else {
          this.r = ((intValue >> 16) & 0xff) / 255;
          this.g = ((intValue >> 8) & 0xff) / 255;
          this.b = (intValue & 0xff) / 255;
        }
        return this;
      }
    }
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this;
  }

  clone() {
    const next = new Color();
    next.r = this.r;
    next.g = this.g;
    next.b = this.b;
    return next;
  }

  _toHsl() {
    const r = this.r;
    const g = this.g;
    const b = this.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0;
    let s = 0;
    const l = (max + min) / 2;

    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }

    return { h, s, l };
  }

  _fromHsl(h, s, l) {
    if (s === 0) {
      this.r = this.g = this.b = l;
      return this;
    }

    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    this.r = hue2rgb(p, q, h + 1 / 3);
    this.g = hue2rgb(p, q, h);
    this.b = hue2rgb(p, q, h - 1 / 3);
    return this;
  }

  offsetHSL(hOffset = 0, sOffset = 0, lOffset = 0) {
    const { h, s, l } = this._toHsl();
    const nh = (h + hOffset) % 1;
    const ns = Math.min(1, Math.max(0, s + sOffset));
    const nl = Math.min(1, Math.max(0, l + lOffset));
    return this._fromHsl(nh < 0 ? nh + 1 : nh, ns, nl);
  }

  getStyle() {
    const r = Math.round(this.r * 255);
    const g = Math.round(this.g * 255);
    const b = Math.round(this.b * 255);
    return `rgb(${r}, ${g}, ${b})`;
  }
}

class Object3D {
  constructor() {
    this.children = [];
    this.parent = null;
    this.position = new Vector3();
    this.rotation = new Euler();
    this.scale = new Vector3(1, 1, 1);
    this.visible = true;
    this.isObject3D = true;
  }

  add(...objects) {
    objects.forEach((obj) => {
      if (!obj || obj === this) return;
      obj.parent = this;
      this.children.push(obj);
    });
    return this;
  }

  remove(object) {
    const index = this.children.indexOf(object);
    if (index >= 0) {
      this.children.splice(index, 1);
      object.parent = null;
    }
    return this;
  }

  traverse(callback) {
    callback(this);
    this.children.forEach((child) => child.traverse(callback));
  }
}

export class Scene extends Object3D {
  constructor() {
    super();
    this.isScene = true;
  }
}

export class Group extends Object3D {
  constructor() {
    super();
    this.isGroup = true;
  }
}

export class PerspectiveCamera extends Object3D {
  constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
    super();
    this.type = 'PerspectiveCamera';
    this.fov = fov;
    this.aspect = aspect;
    this.near = near;
    this.far = far;
    this.zoom = 1;
  }

  updateProjectionMatrix() {
    // No-op for lightweight renderer; values are consumed directly during projection.
  }
}

export class BoxGeometry {
  constructor(width = 1, height = 1, depth = 1) {
    this.type = 'BoxGeometry';
    this.parameters = { width, height, depth };
  }
}

class Material {
  constructor(params = {}) {
    this.transparent = Boolean(params.transparent);
    this.opacity = params.opacity ?? 1;
  }
}

export class MeshStandardMaterial extends Material {
  constructor(params = {}) {
    super(params);
    this.color = new Color(params.color || '#ffffff');
    this.metalness = params.metalness ?? 0;
    this.roughness = params.roughness ?? 1;
  }

  clone() {
    return new MeshStandardMaterial({
      color: this.color.clone(),
      metalness: this.metalness,
      roughness: this.roughness,
      opacity: this.opacity,
      transparent: this.transparent,
    });
  }
}

export class MeshBasicMaterial extends Material {
  constructor(params = {}) {
    super(params);
    this.color = new Color(params.color || '#ffffff');
  }

  clone() {
    return new MeshBasicMaterial({
      color: this.color.clone(),
      opacity: this.opacity,
      transparent: this.transparent,
    });
  }
}

export class Mesh extends Object3D {
  constructor(geometry = new BoxGeometry(), material = new MeshStandardMaterial()) {
    super();
    this.geometry = geometry;
    this.material = material;
    this.isMesh = true;
  }
}

class Light extends Object3D {
  constructor(color = '#ffffff', intensity = 1) {
    super();
    this.color = new Color(color);
    this.intensity = intensity;
    this.isLight = true;
  }
}

export class DirectionalLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = 'DirectionalLight';
  }
}

export class AmbientLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = 'AmbientLight';
  }
}

function drawMesh(ctx, mesh, camera, width, height) {
  const params = mesh.geometry?.parameters || { width: 1, height: 1, depth: 1 };
  const scale = Math.min(width, height) * 0.08;
  const posX = width / 2 + mesh.position.x * scale * 0.3;
  const posY = height / 2 - mesh.position.y * scale * 0.2;
  const depth = mesh.position.z * 0.3;
  const baseWidth = Math.max(0.3, params.width) * scale * 0.35;
  const baseHeight = Math.max(0.2, params.height) * scale * 0.25;
  const depthOffset = Math.max(0.2, params.depth) * scale * 0.25;
  const angle = mesh.rotation?.y || 0;
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const offsetX = depthOffset * cos;
  const offsetY = depthOffset * sin * 0.4;

  const fill = mesh.material?.color?.getStyle?.() || 'rgba(255,255,255,0.8)';
  const topFill = adjustColor(fill, 0.1);
  const sideFill = adjustColor(fill, -0.15);

  ctx.save();
  ctx.translate(depth, depth * 0.1);

  // Top face
  ctx.beginPath();
  ctx.moveTo(posX - baseWidth / 2, posY - baseHeight - offsetY);
  ctx.lineTo(posX + baseWidth / 2, posY - baseHeight - offsetY);
  ctx.lineTo(posX + baseWidth / 2 + offsetX, posY - baseHeight);
  ctx.lineTo(posX - baseWidth / 2 + offsetX, posY - baseHeight);
  ctx.closePath();
  ctx.fillStyle = topFill;
  ctx.fill();

  // Front face
  ctx.beginPath();
  ctx.moveTo(posX - baseWidth / 2, posY);
  ctx.lineTo(posX + baseWidth / 2, posY);
  ctx.lineTo(posX + baseWidth / 2, posY - baseHeight);
  ctx.lineTo(posX - baseWidth / 2, posY - baseHeight);
  ctx.closePath();
  ctx.fillStyle = fill;
  ctx.fill();

  // Side face
  ctx.beginPath();
  ctx.moveTo(posX + baseWidth / 2, posY);
  ctx.lineTo(posX + baseWidth / 2 + offsetX, posY + offsetY);
  ctx.lineTo(posX + baseWidth / 2 + offsetX, posY - baseHeight + offsetY);
  ctx.lineTo(posX + baseWidth / 2, posY - baseHeight);
  ctx.closePath();
  ctx.fillStyle = sideFill;
  ctx.fill();

  ctx.restore();
}

function adjustColor(color, delta) {
  const ctx = adjustColor._ctx || (adjustColor._ctx = document.createElement('canvas').getContext('2d'));
  ctx.fillStyle = color;
  const computed = ctx.fillStyle;
  const rgb = computed
    .replace(/^rgb\(/, '')
    .replace(/\)$/, '')
    .split(',')
    .map((v) => parseInt(v.trim(), 10));
  const [r, g, b] = rgb;
  const hsl = rgbToHsl(r / 255, g / 255, b / 255);
  const next = hslToRgb(hsl.h, hsl.s, Math.min(1, Math.max(0, hsl.l + delta)));
  return `rgb(${Math.round(next.r * 255)}, ${Math.round(next.g * 255)}, ${Math.round(next.b * 255)})`;
}

function rgbToHsl(r, g, b) {
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0;
  let s = 0;
  const l = (max + min) / 2;

  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h, s, l };
}

function hslToRgb(h, s, l) {
  if (s === 0) {
    return { r: l, g: l, b: l };
  }
  const hue2rgb = (p, q, t) => {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  };
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return { r, g, b };
}

export class WebGLRenderer {
  constructor({ canvas, antialias } = {}) {
    this.domElement = canvas || document.createElement('canvas');
    this.domElement.classList.add('three-canvas');
    this._ctx = this.domElement.getContext('2d', { alpha: false, antialias: Boolean(antialias) });
    this._pixelRatio = window.devicePixelRatio || 1;
    this._clearColor = 'rgba(0, 0, 0, 1)';
    this._width = this.domElement.clientWidth || 300;
    this._height = this.domElement.clientHeight || 150;
  }

  setPixelRatio(ratio = 1) {
    this._pixelRatio = ratio;
    return this;
  }

  setSize(width, height, updateStyle = true) {
    this._width = width;
    this._height = height;
    const w = Math.max(1, Math.floor(width * this._pixelRatio));
    const h = Math.max(1, Math.floor(height * this._pixelRatio));
    this.domElement.width = w;
    this.domElement.height = h;
    if (updateStyle !== false) {
      this.domElement.style.width = `${width}px`;
      this.domElement.style.height = `${height}px`;
    }
  }

  setClearColor(color) {
    this._clearColor = typeof color === 'string' ? color : color?.getStyle?.() || '#000';
  }

  render(scene, camera) {
    if (!scene || !camera || !this._ctx) return;
    const ctx = this._ctx;
    ctx.save();
    ctx.setTransform(this._pixelRatio, 0, 0, this._pixelRatio, 0, 0);
    ctx.clearRect(0, 0, this._width, this._height);
    ctx.fillStyle = this._clearColor;
    ctx.fillRect(0, 0, this._width, this._height);

    const meshes = [];
    scene.traverse((obj) => {
      if (obj && obj.isMesh && obj.visible !== false) {
        meshes.push(obj);
      }
    });
    meshes.sort((a, b) => a.position.z - b.position.z);
    meshes.forEach((mesh) => drawMesh(ctx, mesh, camera, this._width, this._height));
    ctx.restore();
  }
}

export const MathUtils = {
  degToRad(value) {
    return value * DEG2RAD;
  },
};

export const REVISION = '161';

export { Color, Euler, Object3D, Vector3 };

export default {
  Color,
  DirectionalLight,
  AmbientLight,
  Scene,
  Group,
  PerspectiveCamera,
  BoxGeometry,
  Mesh,
  MeshStandardMaterial,
  MeshBasicMaterial,
  WebGLRenderer,
  MathUtils,
  Vector3,
  Euler,
  REVISION,
};
